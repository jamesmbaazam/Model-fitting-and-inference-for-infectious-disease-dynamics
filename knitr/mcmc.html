<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Practical session: Fitting a deterministic model with MCMC</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Practical session: Fitting a deterministic model with MCMC</h1>

<h2>Introduction</h2>

<p>For this session, you will fit a deterministic SIR model to a recent measles outbreak in Europe, making use of the model simulation and likelihood functions from the last session. The data is in the &ldquo;measles&rdquo; data set, and can be loaded with</p>

<pre><code class="r">data(measles)
</code></pre>

<p>You can look at the data set with</p>

<pre><code class="r">measles
</code></pre>

<p>or visualise them using <code>plot</code> or <code>ggplot</code>, e.g.</p>

<pre><code class="r">library(ggplot2)
ggplot(measles, aes(x = time, y = Inc)) + geom_point()
</code></pre>

<p>You will use the likelihood and model simulation functions from the last session.</p>

<h2>Prior</h2>

<p>First, you need to decide on the prior distribution of the different parameters, such as <code>R0</code>, the infectious period, etc. The <code>fitparam</code> class has a structure set up for this: you can pass a prior distribution by setting the <code>prior</code> parameter. This expects an R <code>list</code> with two elements: <code>distribution</code>, a name of a density function for the prior distribution, and <code>parameter</code>, a named vector of parameters to pass to the <code>distribution</code> functions. Distribution functions in R start with the letter <code>d</code>. Common ones which might be useful for prior distributions are <code>dunif</code> and <code>dnorm</code>. A good resource for the most commonly used probability distributions can be found in the <a href="http://www.r-tutor.com/elementary-statistics/probability-distributions">R tutorial ebook</a>.</p>

<p>Example:</p>

<pre><code class="r">R0 &lt;- fitparam(name = &quot;R0&quot;,
               value = 2,
               prior = list(distribution = &quot;dunif&quot;,
                            parameters = c(min = 1, max = 5)))
</code></pre>

<p>To calculate the model prior, you have to take the product of all individual model prior (or sum the logged priors). There is already a function to do this for you, called <code>compositeLogPrior</code>. It takes a list of <code>fitparam</code> objects and returns the composite prior from the specified prior distributions.</p>

<p>Example: if you have fitparam objects <code>R0</code> and <code>infectious.period</code> defined,</p>

<pre><code class="r">compositeLogPrior(list(R0))
</code></pre>

<pre><code>## [1] -1.386
</code></pre>

<p>Using this, write a function to calculate the prior:</p>

<pre><code class="r">my_logPrior &lt;- function(list.fitparam) {

    ## calculate the composite prior for the given parameter list

    ## return the logged prior probability
}
</code></pre>

<p>Once you have done this, you can pass the prior function to a <code>fitmodel</code> object. For example, if you have two fitparam objects <code>R0</code> and <code>infectious.period</code>, and a function <code>my_logPrior</code>, you can call</p>

<pre><code class="r">my_SIR &lt;- fitmodel(name = &quot;SIR&quot;,
                   state.variables = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;),
                   list.fitparam = list(R0),
                   log.prior.fitparam = my_logPrior)
</code></pre>

<pre><code>## log.prior(theta) should return a single finite value
## Test: -1.386 
## --&gt; log.prior looks good!
</code></pre>

<p><code>fitmodel</code> converts the prior function into a function that takes a named parameter vector <code>theta</code>, available as <code>SIR$log.prior</code> (see the <code>fitmodel</code> documentation). You can then use this to evaluate the prior at different parameter values:</p>

<pre><code class="r">my_SIR$log.prior(c(R0 = 3))
</code></pre>

<pre><code>## [1] -1.386
</code></pre>

<p>You will probably get a different value, depending on your prior function.</p>

<h2>Posterior</h2>

<p>To calculate the posterior for a given parameter, write a function that takes a vector <code>theta</code> of named parameters and returns a logged posterior probability.</p>

<pre><code class="r">my_posterior &lt;- function(fitmodel, theta) {

    ## calculate the fitmodel prior for parameter theta

    ## calculate the fitmodel likelihood for parameter theta

    ## return the logged posterior probability
}
</code></pre>

<p>When called with a <code>fitmodel</code> and a vector of named parameters <code>theta</code>, it should return the value of the posterior at that value of <code>theta</code>, e.g.</p>

<pre><code class="r">theta &lt;- c(R0 = 15, IP = 2, rho = 0.5, pI0 = 35 / 7.3e+6, pR0 = 0.9, N = 7.3e+6)
my_posterior(my_SIR, theta)
</code></pre>

<pre><code>## [1] -98544
</code></pre>

<p>You will probably get a different value, depending on your prior and likelihood functions.</p>

<h2>MCMC</h2>

<p>To sample from a distribution using MCMC, write a function that takes a target distribution like your posterior (i.e., a function that takes one argument, <code>theta</code>), an initial <code>init.theta</code>, a covariance matrix and the number of iterations. It should evaluate the target function at <code>init.theta</code> and then apply the Metropolis-Hastings algorithm for the specified number of iterations.</p>

<p>To draw a random vector from a multivariate Gaussian proposal distribution, you can use the function <code>rmvnorm</code>, see <code>?rmvnorm</code>. To draw a random number between 0 and 1, you can use <code>runif(n = 1)</code>.</p>

<pre><code class="r">## This is a function that takes four parameters:
## - target: the target distribution, a function that takes one argument
##           (a vector) and returns the (logged) value of a distribution
## - theta.init: the initial value of theta, a named vector
## - covmat.proposal: the covariance matrix of the (Gaussian) proposal distribution,
##                    in the same order as in the &quot;target&quot; vector
## - n.iterations: the number of iterations
## it returns an MCMC trace (value of theta and target(theta) at every MCMC step)
my_mcmc &lt;- function(target, theta.init, covmat.proposal, n.iterations) {

    ## evaluate the function &quot;target&quot; at &quot;theta.init&quot;

    ## repeat n.iterations times:

    ## - draw a new theta from the (multivariate Gaussian) proposal distribution

    ## - evaluate the function target at the proposed theta

    ## - draw a random number between 0 and 1

    ## - accept or reject by comparing the random number to the acceptance probability
    ##   use a Gaussian proposal distribution; what does this look like for the 
    ##   multivariate Gaussian? It&#39;s easiest if you assume the target distribution
    ##   returns the logarithm of its value at theta.

    ## return the chain (i.e., the value of the current theta at every iteration)

}
</code></pre>

<p>You will probably find it useful to save the state of the chain (i.e., the value of <code>theta</code> at every iteration) and the current acceptance probability (i.e., the proportion of proposed <code>theta</code>s that are being accepted) in a data frame or vector.</p>

<p>If you have trouble filling the empty bits in, have a look at our <a href="mcmc_example.md">example</a>.</p>

<p>You can use the Metropolis-Hastings sampler to sample from any target distribution. For example, imagine you don&#39;t know how to draw a normal distribution. You could use your sampler for this. First, let&#39;s define an intermediate function that returns the log of the N(0, 1) normal probability distribution at a given sampled value:</p>

<pre><code class="r">dnorm.log &lt;- function(x) {
  return(dnorm(x, log = T))
}
</code></pre>

<p>Next, use your MCMC sampler</p>

<pre><code class="r">sample.sd &lt;- 1
sigma &lt;- matrix(sample.sd, nrow = 1)

starting.value &lt;- c(x = 1)
iter &lt;- 1000
trace &lt;- my_mcmc(target = dnorm.log, theta.init = starting.value, 
                 covmat.proposal = sigma, n.iterations = iter)
</code></pre>

<p>You can visualise the sampling result using</p>

<pre><code class="r">library(ggplot2)
p &lt;- ggplot(trace, aes(x = x, y = ..count../sum(..count..)))
p &lt;- p + geom_histogram(binwidth = 0.2)
p
</code></pre>

<p>and a trace of the sampler using</p>

<pre><code class="r">trace$iteration &lt;- seq(1, nrow(trace))

p &lt;- ggplot(trace, aes(x = iteration, y = x))
p &lt;- p + geom_line()
p
</code></pre>

<h2>Using MCMC to sample from the posterior</h2>

<p>To get the covariance matrix of a <code>fitmodel</code>, you can use the <code>sd.proposal</code> argument of <code>fitparam</code>, e.g. This sets the covariance matrix to be diagonal, that is the proposals for each parameter will not depend on the other parameters, but will be independently normally distributed, with the standard deviation given by <code>sd.proposal</code>.</p>

<pre><code class="r">R0 &lt;- fitparam(name = &quot;R0&quot;,
               value = 2,
               prior = list(distribution = &quot;dunif&quot;,
                            parameters = c(min = 1, max = 5)),
               sd.proposal = 0.1)
</code></pre>

<p>Once you pass this to a <code>fitmodel</code> (in <code>parameters</code>), it will return the covariance matrix containing all the parameters in <code>fitmodel$gaussian.proposal$covmat</code>.</p>

<pre><code class="r">my_SIR &lt;- fitmodel(name = &quot;SIR&quot;,
                   state.variables = c(&quot;S&quot;, &quot;I&quot;, &quot;R&quot;, &quot;Inc&quot;),
                   list.fitparam = list(R0, InfectiousPeriod, ReportingRate, PopSize,
                                        proportionI0, proportionR0),
                   log.prior.fitparam = my_logPrior,
                   log.likelihood = my_logLikelihood,
                   simulate.model = my_simulateDeterministic,
                   initialise.state = my_initialiseState,
                   data = measles,
                   verbose = F)
my_SIR$gaussian.proposal$covmat
</code></pre>

<pre><code>##       R0   IP  rho N       pI0   pR0
## R0  0.01 0.00 0.00 0 0.000e+00 0e+00
## IP  0.00 0.25 0.00 0 0.000e+00 0e+00
## rho 0.00 0.00 0.01 0 0.000e+00 0e+00
## N   0.00 0.00 0.00 0 0.000e+00 0e+00
## pI0 0.00 0.00 0.00 0 1.877e-14 0e+00
## pR0 0.00 0.00 0.00 0 0.000e+00 1e-04
</code></pre>

<p>You will probably see a different matrix, depending on the proposal standard deviations you have set.</p>

<p>Once you have this, you can pass the proposal covariance matrix and posterior distributions to your MCMC sampler to explore the posterior.</p>

</body>

</html>

