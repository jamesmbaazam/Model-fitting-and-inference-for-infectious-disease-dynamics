<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Inference with ABC</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="github-pandoc.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Inference with ABC</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#objectives">Objectives</a></li>
<li><a href="#background">Background</a><ul>
<li><a href="#summary-statistics">Summary statistics</a></li>
<li><a href="#distance-between-observed-and-simulated-summary-statistics">Distance between observed and simulated summary statistics</a></li>
<li><a href="#abc-posterior-estimate">ABC posterior estimate</a></li>
<li><a href="#abc-mcmc-on-the-stochastic-model">ABC-MCMC on the stochastic model</a></li>
<li><a href="#comparison-with-exact-posterior">Comparison with exact posterior</a></li>
</ul></li>
<li><a href="#going-further">Going further</a></li>
</ul>
</div>
<p><a href="slides/abc_slides.pdf">Lecture slides</a></p>
<h1 id="objectives">Objectives</h1>
<p>The aim of this practical is to use Approximate Bayesian Computation (ABC) to circumvent the need for a tractable likelihood function when fitting your model. More specifically, you will</p>
<ol style="list-style-type: decimal">
<li>write some functions to evaluate summary statistics</li>
<li>use the summary statistics to calculate a distance between model runs and the data</li>
<li>approximate the SEITL model posterior using ABC-MCMC</li>
<li>compare an approximated posterior from ABC with the true posterior</li>
</ol>
<p>To illustrate ABC, you are again going to fit the <a href="play_with_seitl.html">SEITL model</a> to the Tristan da Cunha epidemics. Although in this case we do have a tractable likelihood function, you may have noticed that it is computationally costly to evaluate with the particle filter for the stochastic SEITL model (i.e., it takes a long time to run), so ABC could be an attractive alternative. Running and evaluating pMCMC and ABC on this same data set also gives us the chance to compare the two approaches.</p>
<h1 id="background">Background</h1>
<p>There are two approximation steps at the core of ABC:</p>
<ul>
<li>it replaces observations with summary statistics. Unless these summary statistics are <a href="http://en.wikipedia.org/wiki/Sufficient_statistic">sufficient</a>, this leads to a possibly less informative posterior density.</li>
<li>we are accepting simulations that are within an <em>acceptance window</em> of the data. Unless the acceptance tolerances are equal to 0, this leads to biased samples from the posterior.</li>
</ul>
<p>On the other hand, we have seen in a previous session that MCMC provides unbiased samples from the true posterior at little cost for the deterministic SEITL model. You will end this session by fitting this deterministic model with ABC and assess the accuracy of your ABC posterior distribution by comparing it with the true posterior.</p>
<p>As before, you can load the stochastic SEITL model and the Tristan da Cunha data set with</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(SEITL_stoch)
<span class="kw">data</span>(FluTdC1971)</code></pre>
<p>Once again, you can plot the Tristan da Cunha data with</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotTraj</span>(<span class="dt">data =</span> FluTdC1971)</code></pre>
<div class="figure">
<img src="figure/abc/ABC_plot_TdC_data.png" />
</div>
<h2 id="summary-statistics">Summary statistics</h2>
<p>First of all, you need to define a set of summary statistics for the time series. Have a look at the figure above and think of statistics that would describe the data, and capture the features you want to capture. Finally, code at least two functions that take a trajectory (with an <code>obs</code> column containing the observations) as input and return the values of your summary statistics.</p>
<pre class="sourceCode r"><code class="sourceCode r">traj &lt;-<span class="st"> </span>FluTdC1971

<span class="co"># a function that takes one parameter:</span>
<span class="co"># - traj: a (model or data) trajectory of observations</span>
my_summaryStat1 &lt;-<span class="st"> </span>function(traj){
    <span class="co"># calculate summary statistic using the &quot;obs&quot; column in traj</span>
}

<span class="co"># test</span>
ss1.data &lt;-<span class="st"> </span><span class="kw">my_summaryStat1</span>(traj)

<span class="co"># write other summary statistics</span></code></pre>
<p>If you have trouble coding these up yourself, have a look at some of our <a href="sumstat_examples.html">examples</a>.</p>
<p>Test how your summary statistics vary with a single set of parameters. You can use the <strong>R</strong> function <code>replicates</code>, which calls the same function a specified number of times. For example, to call the <code>ssSize</code> function from the <a href="sumstat_examples.html">examples</a> (which calculates final size) on 100 generated observation trajectories, you can use</p>
<pre class="sourceCode r"><code class="sourceCode r">theta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">R0 =</span> <span class="dv">2</span>, <span class="dt">D.lat =</span> <span class="dv">2</span>, <span class="dt">D.inf =</span> <span class="dv">2</span>, <span class="dt">alpha =</span> <span class="fl">0.9</span>, <span class="dt">D.imm =</span> <span class="dv">13</span>, <span class="dt">rho =</span> <span class="fl">0.85</span>)
init.state &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">S =</span> <span class="dv">250</span>, <span class="dt">E =</span> <span class="dv">0</span>, <span class="dt">I =</span> <span class="dv">4</span>, <span class="dt">T =</span> <span class="dv">0</span>, <span class="dt">L =</span> <span class="dv">30</span>, <span class="dt">Inc =</span> <span class="dv">0</span>)
<span class="kw">hist</span>(<span class="kw">replicate</span>(<span class="dv">100</span>, <span class="kw">ssSize</span>(<span class="kw">genObsTraj</span>(SEITL_stoch, theta, init.state, FluTdC1971$time))), <span class="dt">xlab =</span> <span class="st">&quot;summary statistic&quot;</span>)</code></pre>
<div class="figure">
<img src="figure/abc/size_hist.png" />
</div>
<p>These are stochastic simulations so of course your histogram will look different. If you created your own function for summary statistics (e.g., <code>my_summaryStat1</code>), replace <code>ssSize</code> in the plot command with that one and test how it varies over different simulation runs. We suggest that you try a few summary statistics to get a feeling for how they vary across simulations.</p>
<p>The last command is easiest read from the inside out: <code>genObsTraj</code> with the given arguments produces an observation trajectory from the <code>SEITL_stoch</code> model, <code>ssSize</code> calculates the final size (i.e., total number of people infected) for such a trajectory, <code>replicates</code> does it 100 times and <code>hist</code> plots the outcome (i.e., the replicates of the final size) as a histogram. Depending on the summary statistic you choose, you might see quite a large amount of variation in the outcome of the summary statistic even with a single set of parameters. This might be a problem later when you define an acceptance window: if it is chosen too large, there is a risk that parameter values are accepted indiscriminately. If it is too small, the acceptance will be low and, consequently, many simulation runs wasted because even good parameter sets will often miss the acceptance window.</p>
<p>Can you check whether your summary statistics are <a href="http://en.wikipedia.org/wiki/Sufficient_statistic">sufficient</a>?</p>
<h2 id="distance-between-observed-and-simulated-summary-statistics">Distance between observed and simulated summary statistics</h2>
<p>The second step is to compare your data with your simulation using a function that computes the distance between your observed and simulated summary statistics. In the most general case, you will want to write a distance function for each summary statistic. Here, let's write a single function that calculates the distance between all summary statistics and returns either a single (e.g., mean) distance or a vector of distances.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># a function that takes 5 arguments:</span>
<span class="co"># - sum.stats: a list of functions to calculate summary statistics</span>
<span class="co"># - data.obs: the trajectory of observations (data)</span>
<span class="co"># - model.obs: a trajectory of simulated observations (model)</span>
my_distance &lt;-<span class="st"> </span>function(sum.stats, data.obs, model.obs) {

    ## start for() loop over all summary stats in the list sum.stats

       <span class="co"># calculate the distance (e.g., absolute difference, relative</span>
       <span class="co"># difference, squared distances etc)</span>

    ## end for () loop
    
    <span class="co"># combine distances (via sum, mean, or others)</span>

    <span class="co"># return an overall distance between the model and data</span>
    <span class="co"># trajectories in terms of the summary statistics. E.g., a vector</span>
    <span class="co"># of distances or a mean distance</span>
}</code></pre>
<p>If you have any trouble writing a function for the distance, have a look at our <a href="distance_examples.html">examples</a>.</p>
<p>Test that your summary distance function returns a sensible value (here, we have assigned the <code>ssMeanRelDistance</code> from the examples to <code>my_distance</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">simu &lt;-<span class="st"> </span><span class="kw">genObsTraj</span>(SEITL_stoch, theta, init.state, FluTdC1971$time)
<span class="kw">ssMeanRelDistance</span>(<span class="dt">sum.stats =</span> <span class="kw">list</span>(ssSize, ssMax),
                  <span class="dt">data.obs =</span> FluTdC1971,
                  <span class="dt">model.obs =</span> simu)</code></pre>
<pre><code>## [1] 0.4717</code></pre>
<p>Again, you can change <code>ssMeanRelDistance</code> to your own <code>my_distance</code> function or one from the <a href="distance_examples.html">examples</a>, and try different things for the list of summary statistics (including more or less than two summary statistics).</p>
<p>You can then test the distribution of distances of the summary statistics from model runs to the summary statistic on the data, in the same way as we did before with the distribution of summary statistics. You can use <code>computeDistanceABC</code> function provided in the <code>fitR</code> package does the leg work for you. It computes the distance between a <code>fitmodel</code> and the <code>data</code> for a single simulation using a given parameter vector <code>theta</code> and initial state <code>init.state</code>. Have a look at the code of <code>computeDistanceABC</code>; all it does is generate a simulated observation trajectory and evaluate the distance using a function passed as an argument. We can test it using</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">computeDistanceABC</span>(<span class="dt">sum.stats =</span> <span class="kw">list</span>(ssSize, ssMax),
                   <span class="dt">distanceABC =</span> ssMeanRelDistance,
                   <span class="dt">fitmodel =</span> SEITL_stoch,
                   <span class="dt">theta =</span> theta,
                   <span class="dt">init.state =</span> init.state,
                   <span class="dt">data =</span> FluTdC1971)</code></pre>
<pre><code>## [1] 0.9675</code></pre>
<p>Again, you can change the list of summary statistics (<code>ssSize</code>, <code>ssMax</code>) and the distance function (<code>ssMeanRelDistance</code>) with your own ones, or other ones from the <a href="sumstat_examples.html">examples</a>.</p>
<p>The returned distance is the outcome of a single simulation run, so you will get a different result here, which will also depend on your choice of distance function and summary statistics.</p>
<p>To plot the distribution of distances from the data for a single set of parameter values <code>theta</code>, you can again use <code>replicate</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(<span class="kw">replicate</span>(<span class="dv">100</span>, <span class="kw">computeDistanceABC</span>(<span class="dt">sum.stats =</span> <span class="kw">list</span>(ssSize, ssMax),
                                       <span class="dt">distanceABC =</span> ssMeanRelDistance,
                                       <span class="dt">fitmodel =</span> SEITL_stoch,
                                       <span class="dt">theta =</span> theta,
                                       <span class="dt">init.state =</span> init.state,
                                       <span class="dt">data =</span> FluTdC1971)),
     <span class="dt">xlab =</span> <span class="st">&quot;distance&quot;</span>)</code></pre>
<div class="figure">
<img src="figure/abc/distances_plot.png" />
</div>
<p>Again, these are stochastic simulations so your histogram will look different, and again you can test this with different summary statistics (including more, or fewer) and distance functions. How widely are the distances distributed for a single set of parameters? This should give you an indication for a reasonable acceptance window. Ideally, you want to have summary statistics that vary a lot between parameter values (so the acceptance window can distinguish between good or bad fits), but not so much within parameter values (so you don't have to reject many runs from good parameters). Finding the right combination summary statistics and distance functions to achieve this can be very difficult, though, and one usually ends up having to make compromises between the two.</p>
<h2 id="abc-posterior-estimate">ABC posterior estimate</h2>
<p>Lastly, write a function that will return the approximated posterior value for a given parameter, based on a single model run.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># a function that takes 7 arguments:</span>
<span class="co"># - epsilon: a vector (if the distance function returns a vector) or</span>
<span class="co">#            single number, the tolerance for ABC</span>
<span class="co"># - sum.stats: list of summary statistic functions</span>
<span class="co"># - distanceABC: ABC distance function</span>
<span class="co"># - fitmodel: model to compare to the data</span>
<span class="co"># - theta: parameter vector</span>
<span class="co"># - init.state: initial state for the simulation</span>
<span class="co"># - data: data to compare the model to</span>
my_ABCLogPosterior &lt;-<span class="st"> </span>function(epsilon, sum.stats, distanceABC,
                               fitmodel, theta, init.state, data) {

    <span class="co"># use computeDistanceABC to calculate a distance between the model</span>
    <span class="co"># and data</span>

    ## if the model distance is within the epsilon window

        <span class="co"># set log.density to the prior</span>

    ## else

        <span class="co"># set log.density to -Inf</span>

    ## end if

    <span class="co"># return log.density, the ABC posterior approximation</span>
}</code></pre>
<p>We don't provide an intermediate solution in this case, but if you are struggling with this have a look at the <code>ABCLogPosterior</code> function that comes packaged in <code>fitR</code> by typing</p>
<pre class="sourceCode r"><code class="sourceCode r">ABCLogPosterior</code></pre>
<p>Once you have coded this function you can perform some tests to calibrate the tolerances.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ABCLogPosterior</span>(<span class="dt">epsilon =</span> <span class="dv">5</span>,
                <span class="dt">sum.stats =</span> <span class="kw">list</span>(ssMax, ssSize),
                <span class="dt">distanceABC =</span> ssMeanRelDistance,
                <span class="dt">fitmodel =</span> SEITL_stoch,
                <span class="dt">theta =</span> theta,
                <span class="dt">init.state =</span> init.state,
                <span class="dt">data =</span> FluTdC1971)</code></pre>
<pre><code>## $log.density
## [1] -12.81
## 
## $trace
##          R0       D.lat       D.inf       alpha       D.imm         rho 
##      2.0000      2.0000      2.0000      0.9000     13.0000      0.8500 
##    distance log.density 
##      0.6398    -12.8145</code></pre>
<p>Again, you can change the list of summary statistics and distance values to some that you have written yourselves, or others from the examples.</p>
<p>You will see that, if your tolerances are too large, you will accept too wide a range of parameter sets. If your tolerances are too small you will have have a better approximation of the posterior but very low acceptance rate.</p>
<h2 id="abc-mcmc-on-the-stochastic-model">ABC-MCMC on the stochastic model</h2>
<p>We are nearly ready to run MCMC to generate samples that follow our ABC estimate of the posterior distribution. Again, however, we need to write a wrapper function that only depends on one parameter. For example (using several summary statistics from the corresponding <a href="sumstat_examples.html">examples</a> and one of the distance functions from the other <a href="distance_examples.html">examples</a>)</p>
<pre class="sourceCode r"><code class="sourceCode r">my_ABCLogPosterior_tdc &lt;-<span class="st"> </span>function(theta) {

    init.state =<span class="st"> </span><span class="kw">c</span>(<span class="dt">S =</span> <span class="dv">279</span>, <span class="dt">E =</span> <span class="dv">0</span>, <span class="dt">I =</span> <span class="dv">2</span>, <span class="dt">T1 =</span> <span class="dv">3</span>, <span class="dt">T2 =</span> <span class="dv">0</span>, <span class="dt">L =</span> <span class="dv">0</span>, <span class="dt">Inc =</span> <span class="dv">0</span>)

    <span class="co"># log posterior with several summary statistics, distance given</span>
    <span class="co"># by the mean relative distance in the summary statistics,</span>
    <span class="co"># tolerance of 2</span>
    log.posterior &lt;-
<span class="st">        </span><span class="kw">ABCLogPosterior</span>(<span class="dt">epsilon =</span> <span class="dv">2</span>,
                        <span class="dt">sum.stats =</span> <span class="kw">list</span>(<span class="dt">ssSize =</span> ssSize,
                                         <span class="dt">ssMax =</span> ssMax,
                                         <span class="dt">ssMaxTime =</span> ssMaxTime,
                                         <span class="dt">ssSum_13_24 =</span> ssSum_13_24,
                                         <span class="dt">ssMax_25_36 =</span> ssMax_25_36,
                                         <span class="dt">ssSum_37_60 =</span> ssSum_37_60),
                        <span class="dt">distanceABC =</span> ssMeanRelDistance,
                        <span class="dt">fitmodel =</span> SEIT2L_stoch,
                        <span class="dt">theta =</span> theta,
                        <span class="dt">init.state =</span> init.state,
                      <span class="dt">data =</span> FluTdC1971)

    <span class="kw">return</span>(log.posterior)
}</code></pre>
<p>Change this function to your own liking, e.g. with different summary statistics, a different distance function, different tolerance etc. Test the function using</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_ABCLogPosterior_tdc</span>(theta)</code></pre>
<pre><code>## $log.density
## [1] -12.81
## 
## $trace
##          R0       D.lat       D.inf       alpha       D.imm         rho 
##       2.000       2.000       2.000       0.900      13.000       0.850 
##    distance log.density 
##       1.194     -12.814</code></pre>
<p>(You will get a different value here, as this is the outcome of a random simulation)</p>
<p>You can now plug this into the <code>mcmcMH</code> (or <code>my_mcmcMH</code>, if you would like to use your own) function. Can you work out the command to run ABC-MCMC? If not, have a look at the <a href="abc_mcmc_solution.html#abc-mcmc-on-the-stochastic-model">solution</a>.</p>
<p>Run ABC-MCMC with various values for the tolerance, different summary statistics and different distance functions. Can you get the MCMC to mix well?</p>
<h2 id="comparison-with-exact-posterior">Comparison with exact posterior</h2>
<p>In the deterministic model, we can calculate the likelihood directly, and don't need an approximation. This is a good test case for the accuracy of ABC, as well as our summary statistics.</p>
<p>Write a wrapper function <code>my_ABCLogPosterior_tdc_det</code> to calculate the posterior using the deterministic model by changing the <code>my_ABCLogPosterior_tdc</code> function.</p>
<p>You can now explore this using the <code>mcmcMH</code> function, and the same command as before. Compare this to MCMC using the <code>SEITL2_deter</code> function directly (in a posterior wrapper function, as you did <a href="play_with_seitl.html#run-mcmc">here</a>). Compare the two using <code>coda</code> plot functions. How good is your the ABC estimate using different summary statistics?</p>
<p>If you have any trouble running the MCMC, have a look at our <a href="abc_mcmc_solution.html#comparison-with-exact-posterior">solution</a>.</p>
<h1 id="going-further">Going further</h1>
<p>A <a href="http://www.genetics.org/content/182/4/1207.full.pdf">paper</a> by Wegmann et al. describes various improvements to the ABC-MCMC algorithm, for example an initial run of ~10000 randomly sampled parameter sets to calibrate the tolerance.</p>
<p>A <a href="http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1002803">recent review of ABC</a> discussed many of the strengths and weaknesses of ABC, as well as recent developments.</p>
<p>Previous: <a href="pmcmc.html">Particle MCMC</a></p>
</body>
</html>
