% Practical session: MCMC diagnostics

```{r echo=FALSE,results="hide",message=FALSE}
opts_chunk$set(fig.cap='')
library(fitR)
example(SIR)
example(SIR_reporting)
```

# Objectives

The aim of this session is to learn how to interpret the results of MCMC sampling, as well as to improve the performance of the sampler. More specifically, you will

1. learn how to use `coda` for assessing and interpreting MCMC runs
2. explore strategies for improving the performance of an Metropolis-Hastings sampler
3. learn about posterior predictive checks to assess the goodness of fit

# Sampling more than one parameter

<!-- If we are fitting more than one parameter, we need to use a multivariate proposal distribution such as the multivariate Gaussian. We have included a function called `mcmcMH`in the `fitR` package which extends the Metropolis-Hastings sampler of the last session to a scenario of multiple parameters by replacing the univariate Gaussian proposal distribution of `my_mcmcMH` with a multivariate Gaussian, using the `rtmvtnorm` from the `tmvtnorm` package. In fact, the `rtmvtnorm` function calculates the probability density of a vector under a *truncated* multivariate Gaussian, that is one that can have boundaries. We will get back to this issue later. -->

<!-- The `mcmcMH` takes the same parameters as the `my_mcmcMH` function you used in the previous practical session, except that it takes a parameter `gaussian.proposal` instead of `proposal.sd`. -->

In the last practical session, we worked through some simple examples where we sampled from a distribution that depends on just one parameter. When fitting dynamic models, on the other hand, we are often faced with the need to fit models with a multitude of parameters, and our MCMC needs to sample from a posterior distribution that depends on all of them.

Getting the acceptance rate to a desired value is much harder when dealing with multiple parameters, but there are a few strategies available for doing so, which we will learn about in this practical session.

The data set `epi3` was generated from an SIR model with unknown basic reproduction number $R_0$ and infectious period $D_\mathrm{inf}$. Try to use the MCMC sampler created in the previous session to generate samples that follow the the posterior density (if you didn't get to write your own MCMC sampler, use the own from our [solution](mcmc_example_solution.md)).

You can visualise the `epi3` data set with

```{r}
plotTraj(data = epi3)
```

```{r}

```

You can use the same command for `my_mcmcMH` you used in the previous practical session, but you need to change the `my_logPosterior_wrap` wrapper function to fit to data set `epi3`. Try a few values for the vector of standard deviations `proposal.sd` and see if you can get acceptance rates of 0.2-0.3.

To get good acceptance rates, it is often a good idea to first consider each parameter individually, and then change the proposal step until a desired acceptance rate is achieved. Once this is done, one can start exploring multiple parameters at once, and carefully adjust the proposal steps to get good acceptance rate. Later, we will look at a way to automatically adapt the proposal steps on the basis of the samples taken so far.

# Assessing and interpreting MCMC runs

We now use the functions from the `coda` library to assess the MCMC runs. This usually implies a graphical assessment of the behaviour of the sampler with respect to each fitted parameter. Use the commands below to assess MCMC runs with different values of the initial parameters `init.theta` and step size `proposal.sd`. If you didn't get any MCMC run to work, you can look at the output of an MCMC run that we did ourselves using

```{r}
data(mcmc)
trace <- mcmc.epi3
head(mcmc.epi3$trace)
```

This run was created using the commands shown [here](mcmc_commands.md). In the following, we assume that you assigned the result of `my_mcmcMH` to a variable called `trace`, but of course you can call this anything you like.

To use `coda`, we first convert our trace to a format that `coda` understands. To this end, we use the `mcmc` command:

```{r}
mcmc.trace <- mcmc(trace)
```

# Improving the performance of the sampler

General discussion

## Adaptive proposal steps

Test from mcmcMH (rename to adaptive?)

## Truncated proposal distributions

Not necessary here probably

# Assessing a fit

Posterior predictive checks

<div>
Previous: [Fitting a deterministic model with MCMC](mcmc.md) Next: [Tristan da Cunha](mcmc_diagnostics.md) (not there yet)
</div>
