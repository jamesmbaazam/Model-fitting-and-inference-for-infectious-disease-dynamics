% Practical session: Fitting a deterministic model with MCMC

```{r echo=FALSE,results="hide"}
opts_chunk$set(fig.cap='')
library(fitR)
example(SIR)
example(SIR_reporting)
```

# Objectives

The aim of this session is to learn how to fit a deterministic SIR model to outbreak data using MCMC. More specifically, in this session you will

1. create function that generates samples from an arbitrary distribution using a Metropolis-Hastings sampler
2. use this function to generate samples from a simple (normal) distribution
3. use this function to generate samples from the posterior distribution
4. use the generated samples to learn about the underlying model

# The Metropolis-Hastings sampler

Let us write a function that samples from an arbitrary distribution using MCMC. For now, let us focus on sampling from a distribution that has a single parameter and use a standard Gaussian proposal distribution. The function we want to write should take four arguments: 1) a function that can evaluate the *target distribution* at any value of its parameter, 2) an initial value for the parameter, 3) the standard deviation of the (Gaussian) proposal distribution to set the step size of the sampler and 4) the number of iterations for which to run the sampler. The function should evaluate the target function at the initial parameter value, and then apply the Metropolis-Hastings algorithm for the specified number of iterations.

Below you find the skeleton of such a function. We have inserted comments for every line that you should insert. If you are struggling at any point, click on the link below the code for a more guided example.

A few useful tips: To draw a random number from a Gaussian distribution, you can use the function `rnorm`, see `?rnorm`. To draw a random number between 0 and 1, you can use `runif(n = 1)`. Also, it would be useful to keep track of the number of accepted samples as we will later use the proportion of accepted runs to evaluate the efficiency of the sampler. Lastly, we can set up our function to pass further arguments to the target distribution (for example, the initial state of the posterior) by using the `...` argument. If we add `...` to the function arguments or the MCMC sampler (see below) we can pass `...` to the target function, in which case all arguments not recognised by the MCMC sampler will be passed on to the target distribution function. For more information on `...`, you can look at the help file for it using `dotsMethods`, and for more hints on using it, click the link below the code for a more guided example.

```{r}
# This is a function that takes four arguments:
# - target: the target distribution, a function that takes one argument
#           (a number) and returns the (logged) value of a distribution
# - theta.init: the initial value of theta, a number
# - proposal.sd: the standard deviation of (Gaussian) proposal distribution
# - n.iterations: the number of iterations
# Any further arguments passed to my_mcmcMH should be passed to the target
# distribution.
# The function should return a vector of samples of theta from the target
# distribution
my_mcmcMH <- function(target.dist, init.theta, proposal.sd, n.iterations, ...) {

    # evaluate the function "target.dist" at parameter value "init.theta"

    # initialise variables to store the current value of theta, the
    # vector of samples, and the number of accepted runs

    # repeat n.iterations times:

    # - draw a new theta from the (Gaussian) proposal distribution
    #   with standard deviation sd

    # - evaluate the function target_dist at the proposed theta,
    #   passing further arguemnts using '...'

    # - calculate the Metropolis-Hastings ratio

    # - draw a random number between 0 and 1

    # - accept or reject by comparing the random number to the
    #   Metropolis-Hastings ratio (acceptance probability); if accept,
    #   change the current value of theta to the proposed theta,
    #   update the current value of the target and keep track of the
    #   number of accepted proposals

    # add the current theta to the vector of samples

    # return the trace of the chain (i.e., the vector of samples)
}
```

```{r echo = FALSE}
source('our_mcmcM.r')
```

If you have trouble filling any of the empty bits in, have a look at our [more guided example](mcmc_example.md).

# Sampling from a simple distribution

In principle, we can use the Metropolis-Hastings sampler to sample from any target distribution. Let us test this: imagine you didn't know how to draw random numbers from a normal distribution centred around 0, with standard deviation 1. You could use the Metropolis-Hastings sampler to do this. In **R**, the function to evaluate the probability density of a number under a normal distribution is called `dnorm`, so that we could write:

```{r results = "hide"}
starting.value <- 1 # starting value for MCMC
sigma <- 1 # standard deviation of MCMC
iter <- 10000
trace <- my_mcmcMH(target.dist = dnorm, init.theta = starting.value,
                   proposal.sd = sigma, n.iterations = iter, log = T)
```

Note that we passed `log = T` as extra parameter, which is passed to the target distribution function `dnorm`.

We will talk later about diagnosing the trace of an MCMC run. For now, you can visualise the trace of your MCMC run (i.e., the sequence of samples over time) using

```{r caption = "", fig.width = 10}
plot(trace, type = "l")
```

And you can plot a histogram of the samples generated using

```{r caption = ""}
hist(trace)
```

This looks reassuringly similar to the normal distribution centred around 0. Try different values for `init.theta` and `proposal.sd`. How do these affect the plots of the trace and the histogram?

<div>
Previous: [Introduction](introduction.md) Next: [Tristan da Cunha outbreak](play_with_seitl.md)
</div>
