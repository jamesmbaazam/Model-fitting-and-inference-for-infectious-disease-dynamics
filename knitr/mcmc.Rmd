```{r echo=FALSE,results="hide"}
library(fitR)
example(SIR)
example(SIR_reporting)
```

# Practical session: Fitting a deterministic model with MCMC

## Objectives

The aim of this session is to learn how to fit a deterministic SIR model to outbreak data using MCMC. More specifically, in this session you will

1. create function that generates samples from an arbitrary distribution using a Metropolis-Hastings sampler
2. use this function to generate samples from a simple (normal) distribution
3. use this function to generate samples from the posterior distribution
4. use the generated samples to learn about the underlying model

## The Metropolis-Hastings sampler

To sample from a distribution using MCMC, write a function that takes a target distribution like your posterior (i.e., a function that takes one argument, `theta`), an initial `init.theta`, a covariance matrix and the number of iterations. It should evaluate the target function at `init.theta` and then apply the Metropolis-Hastings algorithm for the specified number of iterations.

To draw a random vector from a multivariate Gaussian proposal distribution, you can use the function `rmvnorm`, see `?rmvnorm`. To draw a random number between 0 and 1, you can use `runif(n = 1)`.

```{r}
my_mcmc <- function(target.dist, init.theta, covariance.matrix, n.iterations) {

    ## evaluate the function target_dist at init_theta

    ## repeat n_iterations times:

    ## - draw a new theta from the (multivariate Gaussian) proposal distribution

    ## - evaluate the function target_dist at the proposed theta

    ## - draw a random number between 0 and 1

    ## - accept or reject by comparing the random number to the acceptance probability

    ## return the chain (i.e., the value of the current theta at every iteration)

}
```

You will probably find it useful to save the state of the chain (i.e., the value of `theta` at every iteration) and the current acceptance probability (i.e., the proportion of proposed `theta`s that are being accepted) in a data frame or vector.

To get the covariance matrix, you can use the `sd.proposal` argument of `fitparam`, e.g. This sets the covariance matrix to be diagonal, that is the proposals for each parameter will not depend on the other parameters, but will be independently normally distributed, with the standard deviation given by `sd.proposal`.

```{r}
R0 <- fitparam(name = "R0",
               value = 2,
               prior = list(distribution = "dunif",
                            parameters = c(min = 1, max = 5)),
               sd.proposal = 0.1)
```

Once you pass this to a `fitmodel` (in `parameters`), it will return the covariance matrix containing all the parameters in `fitmodel$gaussian.proposal$covmat`.

```{r echo=FALSE}
my_logLikelihood <- SIR_logLikelihood
my_simulateDeterministic <- SIR_simulateDeterministic
my_initialiseState <- SIR_initialiseState
```

```{r}
my_SIR <- fitmodel(name = "SIR",
                   state.variables = c("S", "I", "R", "Inc"),
                   list.fitparam = list(R0, InfectiousPeriod, ReportingRate, PopSize,
                                        proportionI0, proportionR0),
                   log.prior.fitparam = my_logPrior,
                   log.likelihood = my_logLikelihood,
                   simulate.model = my_simulateDeterministic,
                   initialise.state = my_initialiseState,
                   data = measles,
                   verbose = F)
my_SIR$gaussian.proposal$covmat
```

You will probably see a different matrix, depending on the proposal standard deviations you have set.


Previous: [Data and likelihood](data_likelihood.md) Next: [Tristan da Cunha outbreak](play_with_seitl.md)
