% Generated by roxygen2 (4.0.1): do not edit by hand
\name{fitmodel}
\alias{fitmodel}
\title{Constructor of fitmodel object}
\usage{
fitmodel(name = NULL, state.variables = NULL, list.fitparam = NULL,
  initialise.state = NULL, simulate.model = NULL,
  generate.observation = NULL, log.prior.fitparam = NULL, data = NULL,
  log.likelihood = NULL, distance.ABC = NULL,
  gaussian.proposal = list(covmat = NULL, lower = NULL, upper = NULL),
  verbose = TRUE)
}
\arguments{
\item{name}{character, name of the model (required)}

\item{state.variables}{character vector, names of the state variables i.e. \code{c("S","I","R","Incidence")} (required)}

\item{list.fitparam}{list of \code{\link{fitparam}} objects. This list will be used to create a named vector of model parameters (\code{theta}), a function to compute the prior (\code{log.prior}) and a list of parameters (including a covariance matrix) for the gaussian proposal kernel (\code{gaussian.proposal}). (required)}

\item{initialise.state}{\R function to initialise the state of the models using the model parameters \code{theta} (optional). This function takes one argument:
\itemize{
    \item \code{theta} named numeric vector of model parameters
}
and returns a numeric vector of initial states, whose names match the vector \code{state.variables}.}

\item{simulate.model}{\R function to simulate forward the model. This function takes 3 arguments:
\itemize{
\item \code{theta} named vector of model parameters.
\item \code{state.init} named vector of initial state of the model.
\item \code{times} time sequence for which state of the model is wanted; the first value of times must be the initial time.
}
and returns a \code{data.fame} containing the values of the state variables (1 per column) at each observation time (1 per row).}

\item{generate.observation}{\R-function to generate simulated data from a simulated trajectory using an observation model. This function takes 2 arguments:
\itemize{
\item \code{model.traj} data.frame of simulated trajectories, as returned by \code{simulate.model}.
\item \code{theta} named vector of model parameters.
}
and return the \code{model.traj} data.frame with an additional "observation" column generated by the observation model. (optional)}

\item{log.prior.fitparam}{\R function to evaluate the log-prior distribution, using the information about priors contained in \code{list.fitparam} (see note below). This function takes one argument
\itemize{
    \item \code{list.fitparam} list of \code{\link{fitparam}} objects.
}
and returns the logged value of the prior density distribution. Required if at least one parameter is estimated. See note below.}

\item{data}{\code{data.frame} of times and observations the model should be fitted to. \code{data} must contain a column named "time" with all observation times. (optional)}

\item{log.likelihood}{\R function to evaluate the log-likelihood of the data given a model parameter \code{theta} and a simulated trajectory \code{model.traj}. This function takes 3 arguments:
\itemize{
\item \code{data} data.frame containing all or part of the observations.
\item \code{theta} named vector of model parameters.
\item \code{model.traj} data.frame containing the state of the model at the successive observation times, as returned by \code{simulate.model}.
}
and return the log-likelihood. (optional)}

\item{distance.ABC}{\R function to evaluate one or more summary distances between the data and a simulated observation. This function takes 2 arguments:
\itemize{
\item \code{data} data.frame containing all or part of the observations.
\item \code{model.traj.obs} data.frame containing simulated observations, as returned by \code{generate.observation}.
}
and return a numeric vector of summary distances. (optional)}

\item{gaussian.proposal}{list of parameters for the - potentially truncated - gaussian proposal distribution of the MCMC. Contains 3 elements:
\itemize{
    \item \code{covmat} covariance matrix. Must have named rows and columns with at least all estimated theta. (optional)
    \item \code{lower} named vector of lower truncation points. Will be set to \code{-Inf} by default.
    \item \code{upper} named vector of upper truncation points. Will be set to \code{Inf} by default.
}}

\item{verbose}{if \code{TRUE}, print details of the test performed to check validity of the arguments}
}
\value{
a \code{fitmodel} object that is a \code{list} of 9 elements:
\itemize{
	\item \code{state.variables} vector names of the state variables.
	\item \code{theta} named vector of the values of model parameters.
	\item \code{initialise.state} \R function to initialise the states of the model; usage: \code{initialise.state(theta)}.
	\item \code{simulate.model} \R function to simulate forward the model; usage: \code{simulate.model(theta,state.init,times)}.
	\item \code{generate.observation} \R function to generate simulated observation; usage: \code{generate.observation(model.traj, theta)}.
	\item \code{log.prior} \R function to evaluate the log-prior; usage: \code{log.prior(theta)}.
	\item \code{data} data.frame with observation times and measures.
	\item \code{log.likelihood} \R function to evaluate the log-likelihood; usage: \code{log.likelihood(data, theta, model.traj)}.
	\item \code{gaussian.proposal} parameters of the gaussian proposal kernel. A list of 3 elements:
	\itemize{
		\item \code{covmat} covariance matrix
		\item \code{lower} lower truncation vector
		\item \code{upper} upper truncation vector
	}
}
}
\description{
A \code{fitmodel} object contains all the information necessary to simulate and fit a model during the course. When a model is created, the constructor performs a serie of checks
on the arguments provided by the user in order to make sure that the different elements of the \code{fitmodel} will be compatible both with the functions coded during the course and the functions
available in the \code{fitcourseR} package. The latter can be used as a correction.
}
\note{
\itemize{
\item The \code{log.prior.fitparam} function can take advantage of the way univariate prior distributions are defined in the \code{\link{fitparam}} object to compute a composite log-prior. See \code{\link{compositeLogPrior}} for more details.
}
}
\examples{
# create a simple stochastic SIR model with constant population size

N <- 7.3e+6
# define model parameters using the fitparam class
R0 <- fitparam(name="R0",value=15,support=c(0,Inf),sd.proposal=1, prior=list(distribution="dunif",parameters=c(min=1,max=100)))

InfectiousPeriod <- fitparam(name="IP",value=2,support=c(0,Inf),sd.proposal=0.5, prior=list(distribution="dunif",parameters=c(min=0,max=30)))

ReportingRate <- fitparam(name="rho",value=0.7,support=c(0,2),sd.proposal=0.1, prior=list(distribution="dunif",parameters=c(min=0,max=2)))

proportionI0 <- fitparam(name="pI0",value=30/N,support=c(0,1),sd.proposal=1/N, prior=list(distribution="dunif",parameters=c(min=1/N,max=300/N)))
proportionR0 <- fitparam(name="pR0",value=0.9,support=c(0,1),sd.proposal=0.01, prior=list(distribution="dunif",parameters=c(min=0.5,max=1)))

PopSize <- fitparam(name="N",value=7.3e+6)

# function to initialise the model
SIR_initialiseState <- function(theta) {

	# constant pop size
	N <- theta[["N"]]

	# number of infected and immune
	I <- round(theta[["pI0"]]*N)
	R <- round(theta[["pR0"]]*N)

	if(I+R>N){
		stop("Initial conditions not valid")
	}

	return(c(S=N-I-R,I=I,R=R,Inc=0))
}



SIR_simulateDeterministic <- function(theta,state.init,times) {

	SIR_ode <- function(time,state,theta) {

        ## param
		beta <- theta[["R0"]]/theta[["IP"]]
		gamma <- 1/theta[["IP"]]
		N <- theta[["N"]]

        ## states
		S <- state["S"]
		I <- state["I"]
		R <- state["R"]
		Inc <- state["Inc"]

		dS <- -beta*S*I/N
		dI <- beta*S*I/N-gamma*I
		dR <- gamma*I
		Inc <- beta*S*I/N

		return(list(c(dS,dI,dR,Inc)))
	}

	trajectory <- data.frame(ode(y=state.init,times=times,func=SIR_ode,parms=theta))

	return(trajectory)
}

SIR_simulateStochastic <- function(theta,state.init,times) {

	# transitions
	SIR_transitions <- list(
		c(S=-1,I=1,Inc=1),# infectiousness + incidence
		c(I=-1,R=1)# recovery
		)

    # rates
	SIR_rateFunc <- function(x,theta,t) {

		# extract theta and states for convenience	when writing the rates
		beta <- theta[["R0"]]/theta[["IP"]]
		nu <- 1/theta[["IP"]]
		N <- theta[["N"]]
		S <- x["S"]
		I <- x["I"]

		return(c(
			beta*S*I/N, # infectiousness + incidence
			nu*I # recovery
			)
		)
	}

	# make use of the function simulateModelStochastic that returns trajectories in the correct format
	return(simulateModelStochastic(theta,state.init,times,SIR_transitions,SIR_rateFunc))

}

SIR_generateObservation <- function(model.traj, theta){

	# daily incidence needed
	incidence <- diff(model.traj$Inc)

	x <- rpois(length(incidence),lambda=theta[["rho"]]*incidence)

	model.traj$observation <- c(0,x)

	return(model.traj)
}

# function to compute log-prior
SIR_logPrior <- function(list.fitparam) {

	theta <- getParameterValues(list.fitparam)

	# check constraint, due to the constant population size, to avoid negative proportion of susceptible as initial condition
	if((theta[["pI0"]]+theta[["pR0"]]) > 1){
		return(-Inf)
	}

	return(compositeLogPrior(list.fitparam))
}

SIR_logLikelihood <- function(data, theta, model.traj){

	# daily incidence needed
	incidence <- diff(model.traj$Inc)

	# keep only data incidence corresponding to simulated times
	data <- subset(data,time\%in\%model.traj$time[-1]) # [-1] to remove initial simulation time

	x <- sum(dpois(x=data$Inc,lambda=theta[["rho"]]*incidence,log=TRUE))

	return(x)
}


SIR <- fitmodel(
	name="SIR",
	state.variables=c("S","I","R","Inc"),
	list.fitparam=list(R0,InfectiousPeriod,ReportingRate,proportionI0,proportionR0,PopSize),
	initialise.state=SIR_initialiseState,
	log.prior.fitparam=SIR_logPrior,
	simulate.model=SIR_simulateDeterministic,
	generate.observation=SIR_generateObservation,
	data=measles,
	log.likelihood=SIR_logLikelihood)





}
\seealso{
fitparam compositeLogPrior
}

