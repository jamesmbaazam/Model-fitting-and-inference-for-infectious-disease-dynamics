---
title: "Practical session: Sampling from an univariate distribution using MCMC"
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(cache=TRUE, fig.path='figure/mcmc/', cache.path='cache/mcmc/' , fig.cap='', fig.align="center")
```

```{r load, include=FALSE, cache=FALSE}
library(fitR)
data(SIR)
data(SIR_reporting)
```

[Lecture slides](slides/mcmc_slides.pdf)

# Objectives

The aim of this session is to learn how to sample from a posterior distribution using MCMC with the Metropolis-Hastings algorithm. More specifically, in this session you will

1. code your first MCMC algorithm to sample from an univariate distribution
2. check your algorithm by sampling from a simple Normal distribution
3. use it to sample from the posterior distribution of $R_0$ from the previous session. 

# My first MCMC sampler

**Code it yourself**: In the next session you will write a function that samples from an arbitrary *target distribution* using MCMC. For now, let us focus on sampling from an univariate distribution, i.e. that has a single parameter, and use a standard Gaussian proposal distribution $q(\theta'|\theta)$. The MCMC function we want to write should take four arguments: 

1. a function that can *evaluate* the target distribution at any value of its parameter
2. an initial value for the parameter
3. the standard deviation of the (Gaussian) *proposal distribution* (i.e., the average step size of the sampler)
4. the number of iterations for which to run the sampler. 

The MCMC function should evaluate the target distribution at the given initial parameter value, and then apply the Metropolis-Hastings algorithm for the specified number of iterations.

Below you will find the skeleton of such a MCMC function. We have inserted comments before every line that you should insert. If you are struggling at any point, click on the link below the code for a more guided example.

__A few useful tips:__ 

* To draw a random number from a Gaussian distribution, you can use the function `rnorm`, see `?rnorm`.
* To draw a uniform random number between 0 and 1, you can use `runif(n = 1)`.
* Also, you will find it useful to keep track of the number of accepted proposal steps as we will use it later to evaluate the efficiency of the sampler.

 <!-- Lastly, we can set up our function to pass any arguments to the target distribution (for example, the initial state of the posterior) by using the `...` argument. If we add `...` to the function arguments or the MCMC sampler (see below) we can pass `...` to the target function, in which case all arguments not recognised by the MCMC sampler will be passed on to the target distribution function. For more information on `...`, you can look at the help file for it using `?dotsMethods`, and for more hints on using it, click the link below the code, which will take you to a more guided example. -->

<!-- Note that 'rnorm' returns an unnamed
    #   vector, but the 'fitmodel' functions use names in the parameter
    #   vector, so you'll have to set the names of the proposed theta
 -->

```{r my_mcmc, eval = FALSE, tidy = FALSE}
# This is a function that takes four arguments:
# - target: the target distribution, a function that takes one argument
#           (a number) and returns the (logged) value of the
#           distribution of interest
# - init.theta: the initial value of theta, the argument for `target`
# - proposal.sd: the standard deviation of the (Gaussian) proposal distribution
# - n.iterations: the number of iterations
# The function should return a vector of samples of theta from the target
# distribution
my_mcmcMH <- function(target, init.theta, proposal.sd, n.iterations) {

    # evaluate the function "target" at parameter value "init.theta"

    # initialise variables to store the current value of theta, the
    # vector of samples, and the number of accepted proposals

    # repeat n.iterations times:

    # - draw a new theta from the (Gaussian) proposal distribution
    #   with standard deviation sd.

    # - evaluate the function "target" at the proposed theta

    # - calculate the Metropolis-Hastings ratio

    # - draw a random number between 0 and 1

    # - accept or reject by comparing the random number to the
    #   Metropolis-Hastings ratio (acceptance probability); if accept,
    #   change the current value of theta to the proposed theta,
    #   update the current value of the target and keep track of the
    #   number of accepted proposals

    # add the current theta to the vector of samples

    # return the trace of the chain (i.e., the vector of samples)
}
```

```{r source_our_mcmc, include = FALSE, tidy = FALSE}
source('our_mcmcMH.r')
```

If you have trouble filling any of the empty bits in, have a look at our [more guided example](mcmc_example.html).

# Sampling from a Normal distribution

In principle, we can use the Metropolis-Hastings sampler you just coded to sample from any target distribution. Before that, and to make sure it works, we are going to test it on a simple distribution. Imagine you didn't know how to draw random numbers from a Normal distribution. You could use the Metropolis-Hastings sampler to do this. In **R**, the function to evaluate the probability density of a number under a Normal distribution is called `dnorm`. It looks like this

```{r dnorm_plot}
plot(dnorm,
     xlim = c(-5, 5),
     ylab = "probability density")
```

We want to generate random numbers that follow the same distribution. There is one small extra step we have to do before we can sample from `dnorm`. Remember that we have set up the Metropolis-Hastings sampler above to expect the target distribution to return the logarithm of the probability density, whereas `dnorm`, by default, returns the (un-logged) probability density.

We can, however, instruct `dnorm` to return the logarithm of the probability density using the argument `log = TRUE`, and we use a *wrapper* function to do so. To sample, for example, from a normal distribution centred around 0, with standard deviation 1, we define a function that takes one argument and returns the logarithm of the probability density at the argument from such a normal distribution

```{r dnorm_log}
dnorm.log <- function(theta) {
   return(dnorm(x = theta, mean = 0, sd = 1, log = TRUE))
}
```

We can now sample from `dnorm.log` using our MCMC sampler

```{r trace, message=FALSE}
starting.value <- 1 # starting value for MCMC
sigma <- 1 # standard deviation of MCMC
iter <- 1000
trace <- my_mcmcMH(target = dnorm.log, init.theta = starting.value,
   proposal.sd = sigma, n.iterations = iter)
```

We will talk later about diagnosing the trace (i.e., the sequence of samples) of an MCMC run. For now, you can visualise the trace of your MCMC run using

```{r plot_trace, fig.width = 7}
plot(trace, type = "l")
```

You can plot a histogram of the samples generated using the function `hist`. Here, since the target is known, you can also check that your samples are normally distributed by using the function `curve`:

```{r hist_trace}
hist(trace, freq = FALSE)
curve(dnorm, from = -4, to = 4, col="red", add=TRUE)
```

This example looks reassuringly similar to the normal distribution centred around 0. Of course, since MCMC is based on sampling random numbers, your plot will look slightly different.

__Take 10 minutes to try different values for `init.theta` and `proposal.sd`. How do these affect the plots of the trace and the histogram?__

# Sampling from a posterior distribution

We can now use our Metropolis-Hastings sampler to sample from the posterior distribution of the previous practical. You should have a `my_dLogPosterior` function that evaluates the posterior distribution at a given value of the parameters and initial state, for a given model and with respect to a given data set (if you don't have this function, you can use the one from our [solution](posterior_example_solution.html)). Again, we need to slightly adapt this to be able to explore it with our Metropolis-Hastings sampler.

Remember that we wrote `my_mcmcMH` to explore a single parameter. Our simplest SIR model, however has two parameters: the basic reproduction number $R_0$ and the duration of infection $D_\mathrm{inf}$. So for now, we are going to keep the duration of infection fixed at 2 weeks and just explore the posterior distribution of $R_0$. 

Lastly, `my_dLogPosterior` takes four parameters, and to use it with the `my_mcmcMH` function we have to turn it into a function that just takes one parameter, here $R_0$. Again, we use a wrapper function for this, which returns the posterior density for a given value of $R_0$ for the `SIR` model with respect to the `epi1` data set, and for fixed `init.state` ($X_0$).


<!-- We can do this by setting `sd.proposal` to a vector of standard deviations, where the second element (if `D_inf` is the second parameter in `theta`) is 0. -->


```{r source_our_logpost, echo=FALSE}
source("our_posterior.r")
```

```{r write_logpost}
my_dLogPosterior_R0_epi1 <- function(R0) {

  return(my_dLogPosterior(fitmodel = SIR,
                          theta = c(R0 = R0, D_inf = 2),
                          init.state = c(S = 999, I = 1, R = 0),
                          data = epi1))
}
```

We can test that this function returns the value of the posterior for a given value of $R_0$.

```{r eval_logpost}
my_dLogPosterior_R0_epi1(R0 = 3)
```

You should get the same number unless you changed the `SIR$pointLogLike` function.

__Take 10 minutes to generate samples from `my_dLogPosterior_R0_epi1` using `my_mcmcMH`. Can you work out the command to do this?__ If you have any problems with this, have a look at our [solution](generate_samples.html).

Once you have generated the samples from the posterior distribution, you can calculate summary statistics such as:

* sample mean of $R_0$ using `mean(trace)`, 
* sample median using `median(trace)`
* 95% credible intervals using `quantile(trace, probs=c(0.025, 0.975))`.

Try to re-run your MCMC with different values for `init.theta` (the starting values for $R_0$), for `proposal.sd` (the standard deviation of the Gaussian proposal distribution $q(\theta'|\theta)$), and for `iter` (the number of iterations). Look at plots generated using `plot` and `hist` (see above), summary statistics and the acceptance rate.

__Take 15 minutes to check how the answers to the following questions depend on parameters:__

1. What is the [maximum a posteriori probability estimate](https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation) (MAP) of $R_0$? Does this match your estimate from the previous session?
2. What determines the acceptance rate?
3. How many iterations do you need to get a good estimate for $R_0$?

In the next session we will look at all of these issues in more detail.

# Going further

Try changing the `my_mcmcMH` function to use different proposal distributions from a normal distributions (e.g., using `runif` or `rlnorm` instead of `rnorm`). How do these affect the three questions above (best estimate, acceptance rate, number of iterations needed)?

<div>
Top: [Index](index.html) Previous: [Introduction](introduction.html) <!--Next: [MCMC diagnostics](mcmc_diagnostics.html)-->
</div>
