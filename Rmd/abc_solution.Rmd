# ABC-MCMC on the stochastic model

```{r setup, echo=FALSE}
knitr::opts_chunk$set(cache=TRUE, fig.path='figure/abc_solution/', cache.path='cache/abc_solution/', fig.cap='', tidy=FALSE)
```
```{r load, include=FALSE, cache=FALSE}
library(fitR)
source("distance_examples.r")
source("sumstat_examples.r")
```

This is how you can run ABC-MCMC on the stochastic model

```{r abc_mcmc, eval = FALSE}
abc.trace <- mcmcMH(target = my_ABCLogPosterior_tdc,
                    init.theta = theta,
                    n.iterations = 1000,
                    limits = list(lower = c(R0 = 1, D_lat = 0, D_inf = 0, D_imm = 0, alpha = 0, rho = 0),
                                  upper = c(R0 = Inf, D_lat = Inf, D_inf = Inf, D_imm = Inf, alpha = 1, rho = 1)))
```

[Return](ABC.html#run-mcmc) to the ABC session.

# Comparison with exact posterior

Just like with the pMCMC we ran yesterday, let us make ourselves easier by informing the starting value and covariance matrix for our ABC-MCMC from a deterministic MCMC run:

```{r trace}
# load results of deterministic fit
data(mcmc_TdC_deter_longRun)

# Let's use the first trace only, no need to burn or thin
trace <- mcmc_SEITL_infoPrior_theta1$trace

# we will start the pMCMC at the mean posterior estimate of the
# deterministic fit
deter.theta <- colMeans(trace[SEITL_stoch$theta.names])

# and we take the empirical covariance matrix for the Gaussian kernel
# proposal
covmat <- mcmc_SEITL_infoPrior_theta1$covmat.empirical

# initial state
init.state <- c(S = 279, E = 0, I = 2, T = 3, L = 0, Inc = 0)
```

The results from the deterministic run were:

```{r summary}
summary(mcmc(mcmc_SEITL_theta1$trace))
```

Now, let us choose a distance function and set of summary statistics, and look at the distance from the data at the posterior mean:

```{r dist_hist_mcmc}
data(SEITL_deter)
hist(replicate(100, computeDistanceABC(sum.stats = list(ssSize, ssMax),
                                       distanceABC = ssMeanRelDistance,
                                       fitmodel = SEITL_deter,
                                       theta = deter.theta,
                                       init.state = init.state,
                                       data = FluTdC1971)),
     xlab = "distance")
```

Now we can define a wrapper function for the ABC posterior. Let's try $\epsilon = 0.3$

```{r write_ABClogpost}
my_ABCLogPosterior_tdc_det <- function(theta) {

    init.state = c(S = 279, E = 0, I = 2, T1 = 3, T2 = 0, L = 0, Inc = 0)

    # log posterior with several summary statistics, distance given
    # by the mean relative distance in the summary statistics,
    # acceptance window of 0.3
    log.posterior <-
        ABCLogPosterior(epsilon = 0.3,
                        sum.stats = list(ssSize = ssSize,
                                         ssMax = ssMax,
                                         ssMaxTime = ssMaxTime,
                                         ssSum_13_24 = ssSum_13_24,
                                         ssMax_25_36 = ssMax_25_36,
                                         ssSum_37_60 = ssSum_37_60),
                        distanceABC = ssMeanRelDistance,
                        fitmodel = SEIT4L_deter,
                        theta = theta,
                        init.state = init.state,
                      data = FluTdC1971)

    return(log.posterior)
}
```

Finally, we use the function `mcmcMH` to generate samples from that distribution

```{r run abc,eval = F}
abc.trace <- mcmcMH(target = my_ABCLogPosterior_tdc_det,
                    init.theta = deter.theta,
                    covmat = covmat, 
                    n.iterations = 1000,
                    limits = list(lower = c(R0 = 1, D_lat = 0, D_inf = 0, D_imm = 0, alpha = 0, rho = 0),
                    upper = c(R0 = Inf, D_lat = Inf, D_inf = Inf, D_imm = Inf, alpha = 1, rho = 1)))

```

To display the results of the MCMC you can use the various plots function of `coda` (`xyplot`, `densityplot`), as well as `summary`, after converting the trace to an `mcmc` object

```{r convert, eval = FALSE}
mcmc.trace <- mcmc(abc.trace$trace)
```

[Return](ABC.html#comparison-with-exact-posterior) to the ABC session.
